package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/bytedance/gg/gmap"
	"github.com/bytedance/gg/gslice"
	"golang.org/x/tools/go/packages"
	"golang.org/x/tools/imports"
)

const (
	workspaceRepo     = "github.com/ray4go/go-ray"
	raytasksComment   = "// raytasks"
	rayactorsComment  = "// rayactors"
	generatedFileName = "ray_workload_wrappers.go"
)

const packageCommentsTPL = `
// Code generated by goray. DO NOT EDIT.
//
// This file was generated by goray.
// It contains wrappers for the ray tasks and actors in this package.
//
// To regenerate this file, run:
//	  goraygen <package-path>
`

func main() {
	if len(os.Args) < 2 {
		fmt.Printf("Usage: goraygen <package-path>\n")
		os.Exit(1)
	}
	packagePath := os.Args[1]
	g := NewGenerator()
	if err := g.Run(packagePath); err != nil {
		log.Fatal(err)
	}
}

// Generator encapsulates state & steps for code generation.
type Generator struct {
	pkg *packages.Package

	tasks          []Method
	actorFactories []Method
	actor2Methods  map[string][]Method // key is actor type name (Method.Name in actorFactories)
	imports        map[string]struct{}

	typeConstraints *ParameterTypeConstraints
}

func NewGenerator() *Generator {
	return &Generator{
		actor2Methods:   make(map[string][]Method),
		imports:         make(map[string]struct{}),
		typeConstraints: &ParameterTypeConstraints{type2ConstraintId: make(map[string]int)},
	}
}

func (g *Generator) Run(packagePath string) error { // orchestrates phases
	if err := g.loadPackage(packagePath); err != nil {
		return err
	}
	g.collectWorkloads()
	g.collectActorMethods()
	code := g.generateCode()
	if err := g.write(code, packagePath); err != nil {
		return err
	}
	return nil
}

func (g *Generator) loadPackage(packagePath string) error {
	absTargetDir, err := filepath.Abs(packagePath)
	if err != nil {
		return fmt.Errorf("get abs path of package error: %w", err)
	}

	cfg := &packages.Config{
		Dir:  absTargetDir,
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedSyntax | packages.NeedTypes,
	}
	pkgs, err := packages.Load(cfg, "./")
	if err != nil {
		return err
	}
	if len(pkgs) == 0 {
		return errors.New("no packages found in " + packagePath)
	}
	g.pkg = pkgs[0]
	if g.pkg.Errors != nil {
		fmt.Printf("%d errors detected when load the package:\n", len(g.pkg.Errors))
		for _, e := range g.pkg.Errors {
			log.Printf("- %v", e)
		}
	}
	return nil
}

func (g *Generator) collectWorkloads() {
	// tasks
	if s := FindStruct(g.pkg, raytasksComment); s != nil {
		fmt.Printf("Found raytasks struct: %s\n", s.Name.Name)
		var imports_ map[string]struct{}
		g.tasks, imports_ = FindMethods(g.pkg, s.Name.Name)
		g.imports = gmap.Merge(g.imports, imports_)
	} else {
		fmt.Printf("No struct with '%s' comment found\n", raytasksComment)
	}
	// actors
	if s := FindStruct(g.pkg, rayactorsComment); s != nil {
		fmt.Printf("Found rayactors struct: %s\n", s.Name.Name)
		var imports_ map[string]struct{}
		g.actorFactories, imports_ = FindMethods(g.pkg, s.Name.Name)
		g.actorFactories = gslice.Filter(g.actorFactories, func(m Method) bool {
			return len(m.Results) > 0
		})
		g.imports = gmap.Merge(g.imports, imports_)
	} else {
		fmt.Printf("No struct with '%s' comment found\n", rayactorsComment)
	}
}

func (g *Generator) collectActorMethods() {
	for _, actorFactory := range g.actorFactories {
		if len(actorFactory.Results) == 0 {
			continue // skip invalid actor factory
		}
		actorTypeName := actorFactory.Results[0].Type
		actorName := strings.TrimPrefix(actorTypeName, "*")
		actorMethods, extraImports := FindMethods(g.pkg, actorName)
		g.imports = gmap.Merge(g.imports, extraImports)
		fmt.Printf("Actor '%s' find %d methods\n", actorName, len(actorMethods))
		g.actor2Methods[actorFactory.Name] = actorMethods
	}
}

func (g *Generator) generateCode() string {
	var buf bytes.Buffer
	buf.WriteString(packageCommentsTPL)
	fmt.Fprintf(&buf, "package %s\n\n", g.pkg.Name)
	writeImports(&buf, g.imports)

	for _, m := range g.tasks {
		generateWrapperFunction(taskDefTpl, &buf, m, g.typeConstraints, "")
	}
	for _, factory := range g.actorFactories {
		actorName := factory.Name
		generateWrapperFunction(actorDefTpl, &buf, factory, g.typeConstraints, actorName)
		for _, am := range g.actor2Methods[actorName] {
			generateWrapperFunction(actorMethodDefTpl, &buf, am, g.typeConstraints, actorName)
		}
	}
	buf.WriteString(g.typeConstraints.buf.String())
	return buf.String()
}

func (g *Generator) write(code, packagePath string) error {
	_ = os.WriteFile("/tmp/out.go", []byte(code), 0o644) // for debug
	formatted, err := format.Source([]byte(code))
	if err != nil {
		log.Printf("Warning: Could not format generated code: %v", err)
		formatted = []byte(code)
	}
	outputFile := filepath.Join(packagePath, generatedFileName)
	formatted, err = imports.Process(outputFile, formatted, nil)
	if err != nil {
		return fmt.Errorf("auto imports error: %w", err)
	}
	if err := os.WriteFile(outputFile, formatted, 0o644); err != nil {
		return err
	}
	fmt.Printf("Generated wrapper code is written to: %s\n", outputFile)
	return nil
}

func writeImports(buf *bytes.Buffer, importSet map[string]struct{}) {
	importSet[fmt.Sprintf(`"%s/ray"`, workspaceRepo)] = struct{}{}
	importSet[fmt.Sprintf(`. "%s/ray/generic"`, workspaceRepo)] = struct{}{}
	if len(importSet) == 0 {
		return
	}
	// deterministic order for stable diffs
	importList := gmap.Keys(importSet)
	sort.Strings(importList)

	fmt.Fprintf(buf, "import (\n")
	for _, imp := range importList {
		fmt.Fprintf(buf, "\t%s\n", imp)
	}
	fmt.Fprintf(buf, ")\n\n")
}

type ParameterTypeConstraints struct {
	buf               bytes.Buffer
	type2ConstraintId map[string]int
}

func (t *ParameterTypeConstraints) RegisterParameter(typeName string) string {
	const typeConstraintPrefix = "_T"
	const typeConstraintTpl = `
type %s%d interface {
	%s | *Future1[%s] | ray.SharedObject[%s]
}
	`
	if id, ok := t.type2ConstraintId[typeName]; ok {
		return fmt.Sprintf("%s%d", typeConstraintPrefix, id)
	}
	typeConstraintId := len(t.type2ConstraintId)
	typeConstraint := fmt.Sprintf(typeConstraintTpl, typeConstraintPrefix, typeConstraintId, typeName, typeName, typeName)
	t.buf.WriteString(typeConstraint)
	t.type2ConstraintId[typeName] = typeConstraintId
	return fmt.Sprintf("%s%d", typeConstraintPrefix, typeConstraintId)
}

func (t *ParameterTypeConstraints) String() string {
	return t.buf.String()
}

/*
	func Echo[any_0 T2](args ...any_0) *RemoteFunc[*Future1[[]any]] {
		_ = (demo).Echo // help you to FindStruct the original task
		return NewRemoteFunc[*Future1[[]any]]("Echo", ExpandArgs([]any{}, args))
	}
*/
const taskDefTpl = `
func {{.FuncName}} {{.TypeConstraints}} ( {{.ParamList}} ) *RemoteFunc[*Future{{.ResLen}}{{.ResTypes}}] {
	_ = ({{.ReceiverType}}).{{.FuncName}}  // help you to findStruct the original task
	return NewRemoteFunc[*Future{{.ResLen}}{{.ResTypes}}]("{{.FuncName}}", {{.ArgsStatement}})
}
`

const actorDefTpl = `
type Actor{{.ActorName}} ray.ActorHandle

func {{.FuncName}} {{.TypeConstraints}} ( {{.ParamList}} ) *RemoteActor[Actor{{.ActorName}}] {
	_ = ({{.ReceiverType}}).{{.FuncName}}  // help you to findStruct the original actor constructor
	return NewRemoteActor[Actor{{.ActorName}}]("{{.FuncName}}", []any{n})
}
`

const actorMethodDefTpl = `
func {{.ActorName}}_{{.FuncName}} {{.TypeConstraints}} (actor Actor{{.ActorName}}, {{.ParamList}}) *RemoteFunc[*Future{{.ResLen}}{{.ResTypes}}] {
	_ = ({{.ReceiverType}}).{{.FuncName}}  // help you to findStruct the original actor method
	return NewRemoteFunc[*Future{{.ResLen}}{{.ResTypes}}]("{{.FuncName}}", {{.ArgsStatement}}, ray.ActorHandle(actor))
}
`

type FuncDef struct {
	FuncName        string
	TypeConstraints string
	ParamList       string
	ResLen          int
	ResTypes        string
	ArgsStatement   string
	ReceiverType    string

	ActorName string // only for actor def
}

func generateWrapperFunction(tpl string, buf *bytes.Buffer, method Method, paramTypeMapper *ParameterTypeConstraints, actorName string) {
	paramNames := make([]string, len(method.Params))
	paramList := make([]string, len(method.Params))
	typeConstraintList := make([]string, len(method.Params))
	for i, param := range method.Params {
		paramNames[i] = param.Name

		paramTypeName := IdentifiableTypeName(param.Type)
		paramTypeName = fmt.Sprintf("%s_%d", paramTypeName, i)
		typeConstraintList[i] = fmt.Sprintf("%s %s", paramTypeName, paramTypeMapper.RegisterParameter(param.Type))

		if i == len(method.Params)-1 && method.IsVariadic {
			// For variadic parameter, we need to remove the [] prefix
			paramList[i] = fmt.Sprintf("%s ...%s", param.Name, paramTypeName)
		} else {
			paramList[i] = fmt.Sprintf("%s %s", param.Name, paramTypeName)
		}
	}
	typeConstraints := strings.Join(typeConstraintList, ", ")
	if len(typeConstraints) > 0 {
		typeConstraints = fmt.Sprintf("[%s]", typeConstraints)
	}

	resTypes := make([]string, len(method.Results))
	for i, res := range method.Results {
		resTypes[i] = res.Type
	}
	resTypesStr := ""
	if len(resTypes) > 0 { // Future0 has no generic type
		resTypesStr = fmt.Sprintf("[%s]", strings.Join(resTypes, ", "))
	}

	argsStatement := fmt.Sprintf("[]any{%s}", strings.Join(paramNames, ", "))
	if method.IsVariadic {
		argsStatement = fmt.Sprintf(
			"ExpandArgs([]any{%s}, %s)",
			strings.Join(paramNames[:len(paramNames)-1], ", "),
			paramNames[len(paramNames)-1],
		)
	}

	funcDef := FuncDef{
		FuncName:        method.Name,
		TypeConstraints: typeConstraints,
		ParamList:       strings.Join(paramList, ", "),
		ResLen:          len(method.Results),
		ResTypes:        resTypesStr,
		ArgsStatement:   argsStatement,
		ReceiverType:    method.ReceiverType,
		ActorName:       actorName,
	}

	tmpl, err := template.New("funcDef").Parse(tpl)
	if err != nil {
		panic(err)
	}
	err = tmpl.Execute(buf, funcDef)
	if err != nil {
		panic(err)
	}
}
